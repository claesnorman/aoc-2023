from typing import Dict
from datetime import datetime


def seed_generator(seeds_text_row: str, max_seeds: int = 0):
    seeds_text = seeds_text_row.split(":")[1].strip().split()

    sum_seeds = 0
    parsed_seed_starts = []
    parsed_seed_ends = []
    for idx in range(int(len(seeds_text) / 2)):
        seed_start = int(seeds_text[2 * idx])
        seed_length = int(seeds_text[2 * idx + 1])
        seed_end = seed_start + seed_length
        # print(f"{seed_length=}")
        sum_seeds += seed_length
        parsed_seed_starts.append(seed_start)
        parsed_seed_ends.append(seed_end)
    if max_seeds and max_seeds < sum_seeds:
        print(f"Initialise seed_generator. This iterator is limited by max_seeds and will yield {max_seeds} seeds out of total {sum_seeds} seeds.")
    else:
        print(f"Initialise seed_generator. This iterator will yield {sum_seeds} seeds")

    seeds_generated = 1
    for seed_start, seed_end in zip(parsed_seed_starts, parsed_seed_ends):
        stop_generating_seeds = False
        for seed in range(seed_start, seed_end):
            yield seed
            seeds_generated += 1
            if max_seeds:
                if seeds_generated == max_seeds:
                    stop_generating_seeds = True
                    break
        if stop_generating_seeds:
            break


def convert_source_to_dest(source: int, conversion_map: Dict) -> int:
    # print(f"Convert src={source} in map={conversion_map['name']}")
    for conversion in conversion_map["conversions"]:
        src_min = conversion["src_range_start"]
        src_max = conversion["src_range_end"]
        if source < src_min or source > src_max:
            # Not this conversion
            continue
        # This conversion covers the source
        dst = conversion["dst_range_start"] + source - src_min
        # print(f"Conversion found, {dst=}")
        return dst
    else:  # No conversion found, then destination = source
        # print(f"No conversion found, return {source=}")
        return source


def main():
    print("Start of script")
    # puzzle_input_filename = "./example_input.txt"
    puzzle_input_filename = "./puzzle_input.txt"
    with open(puzzle_input_filename) as f:
        file_content = f.readlines()
    file_content = [x.strip() for x in file_content]

    # for row in file_content:
    #     print(f"{row}")

    # Find all mappings
    source_to_dest_maps = []
    source_to_dest_map = {}
    idx = 0
    for row in file_content:
        if "seeds:" in row:
            continue
        row = row.strip()
        if not row:
            continue
        # print(f"{row}")
        if ":" in row:  # Start of new map
            # Save old map if any, and clean 'work in progress' map
            if source_to_dest_map:
                source_to_dest_maps.append(source_to_dest_map)
            source_to_dest_map = {"index": idx, "name": row.rstrip(":").split()[0], "conversions": []}
            idx += 1
            continue
        numbers = row.split()
        conversion = {"dst_range_start": int(numbers[0]),
                      "src_range_start": int(numbers[1]),
                      "src_range_end": int(numbers[1]) + int(numbers[2]) - 1}
        source_to_dest_map["conversions"].append(conversion)

    # Reached end of file, add the last map to maps
    source_to_dest_maps.append(source_to_dest_map)
    # for source_to_dest_map in source_to_dest_maps:
    #     print(f"{source_to_dest_map=}")

    # Since weÂ´re interested in the lowest location only (which is the last conversion), then we only need to keep the lowest conversion)
    # last_source_to_dest_map = source_to_dest_maps[-1]
    # print(f"Let's manipulate the last conversion map with name: {last_source_to_dest_map['name']}")
    # sorted_conversions = sorted(last_source_to_dest_map["conversions"], key=lambda x: x["dst_range_start"])
    # new_last_map = {"name": last_source_to_dest_map["name"], "conversions": [sorted_conversions[0]]}
    # source_to_dest_maps.pop()
    # source_to_dest_maps.append(new_last_map)
    # for source_to_dest_map in source_to_dest_maps:
    #     print(f"{source_to_dest_map=}")
    # exit()

    start = datetime.now()
    # Start iterating over the seeds generated by seed_generator
    last_source_to_dest_map = len(source_to_dest_maps)-1
    lowest_location = 9999999999
    idx = 1
    seeds_text_row = file_content[0]
    for seed in seed_generator(seeds_text_row=seeds_text_row):
        # The seed is the initial source
        src = seed
        for conversion_map in source_to_dest_maps:
            dst = convert_source_to_dest(source=src, conversion_map=conversion_map)
            if conversion_map["index"] == last_source_to_dest_map:
                # if conversion_map["name"] == "humidity-to-location":
                # We reached the end of the chain
                if dst < lowest_location:
                    lowest_location = dst
                break
            # This conversion map's destination will be the source of the next conversion map
            src = dst
        idx += 1
        if idx % 1000000 == 0:
            print(f"Number of seeds processed so far: {idx:,}")
    end = datetime.now()
    print(f"Total number of processed seeds: {idx:,}")
    print(f"Process time: {end-start}")
    print(f"{lowest_location=}")


if __name__ == "__main__":
    main()
